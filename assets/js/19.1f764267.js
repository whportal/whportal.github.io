(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{501:function(_,v,l){"use strict";l.r(v);var i=l(4),t=Object(i.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("div",{staticClass:"custom-block tip"},[l("p",[_._v("Java 设计模式及设计原则的理解与使用，更新中...")])]),_._v(" "),l("h2",{attrs:{id:"设计原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[_._v("#")]),_._v(" 设计原则")]),_._v(" "),l("h3",{attrs:{id:"_1-开闭原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-开闭原则"}},[_._v("#")]),_._v(" 1_开闭原则")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("定义")]),_._v(" "),l("ul",[l("li",[_._v("开闭原则（Open Closed Principle，OCP）：软件实体应当对扩展开放(对提供方)，对修改关闭(对使用方)")])])]),_._v(" "),l("li",[l("p",[_._v("实现")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("通过“抽象约束、封装变化实现”实现")]),_._v(" "),l("blockquote",[l("p",[_._v("即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中,当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化")])])]),_._v(" "),l("li")])])]),_._v(" "),l("h3",{attrs:{id:"_2-单一职责原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-单一职责原则"}},[_._v("#")]),_._v(" 2_单一职责原则")]),_._v(" "),l("ul",[l("li",[l("p",[_._v("定义")]),_._v(" "),l("ul",[l("li",[_._v("单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，即一个类只应该负责一项职责")])])]),_._v(" "),l("li",[l("p",[_._v("实现")]),_._v(" "),l("ul",[l("li",[_._v("发现类的不同职责并将其分离，再封装到不同的类或模块中")])])]),_._v(" "),l("li",[l("p",[_._v("注意")]),_._v(" "),l("ul",[l("li",[_._v("通常情况下我们应该遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中的方法数量足够少，才可以在方法级别保持单一职责原则")])])])]),_._v(" "),l("h3",{attrs:{id:"_3-接口隔离原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-接口隔离原则"}},[_._v("#")]),_._v(" 3_接口隔离原则")]),_._v(" "),l("ul",[l("li",[_._v("定义\n"),l("ul",[l("li",[_._v("Interface Segregation Principle，客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上，要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用")])])]),_._v(" "),l("li",[_._v("实现\n"),l("ul",[l("li",[_._v("接口尽量小，一个接口只服务于一个子模块或业务逻辑")]),_._v(" "),l("li",[_._v("为依赖接口的类提供定制服务，即只提供调用者需要的方法，屏蔽不需要的方法")]),_._v(" "),l("li",[_._v("提高内聚，减少对外交互，使接口用最小的方法去完成最多的事情")])])])]),_._v(" "),l("h3",{attrs:{id:"_4-依赖倒置原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-依赖倒置原则"}},[_._v("#")]),_._v(" 4_依赖倒置原则")]),_._v(" "),l("ul",[l("li",[_._v("定义\n"),l("ul",[l("li",[_._v("依赖倒置原则（Dependence Inversion Principle，DIP）高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。==要面向接口编程，不要面向实现编程。==")])])]),_._v(" "),l("li",[_._v("实现\n"),l("ul",[l("li",[_._v("每个类尽量提供接口或者抽象类，或者两者都具备")]),_._v(" "),l("li",[_._v("变量的声明类型尽量是接口或者抽象类")]),_._v(" "),l("li",[_._v("任何类都不应该从具体类派生")]),_._v(" "),l("li",[_._v("使用继承时尽量遵循里氏替换原则")])])])])])}),[],!1,null,null,null);v.default=t.exports}}]);